package task1

import "Algorithms/laboratory_work2/controller"

// Функция GaussJordan решает систему линейных уравнений методом Гаусса-Жордана с выбором ведущего элемента.
// Принимает на вход матрицу коэффициентов A и вектор свободных членов B.
// Возвращает решение системы в виде одномерного среза X или ошибку, если система не имеет решения или имеет бесконечно много решений.
func GaussJordan(A [][]float64, B []float64) ([]float64, error) {
	// n - количество уравнений в системе
	n := len(A)
	// X - массив, в который будут записаны решения системы
	X := make([]float64, n)

	// Прямой ход метода Гаусса-Жордана с выбором ведущего элемента
	for i := 0; i < n; i++ {
		// Находим строку с максимальным элементом в текущем столбце
		maximum := i
		for j := i + 1; j < n; j++ {
			if controller.Abs(A[j][i]) > controller.Abs(A[maximum][i]) {
				maximum = j
			}
		}
		// Меняем местами текущую строку и строку с максимальным элементом
		A[i], A[maximum] = A[maximum], A[i]
		B[i], B[maximum] = B[maximum], B[i]

		// Приводим текущий столбец к единичному виду
		for j := i + 1; j < n; j++ {
			f := A[j][i] / A[i][i]
			for k := i; k < n; k++ {
				A[j][k] -= A[i][k] * f
			}
			B[j] -= B[i] * f
		}
	}

	// Обратный ход метода Гаусса-Жордана
	for i := n - 1; i >= 0; i-- {
		// Вычисляем значение переменной X[i]
		X[i] = B[i] / A[i][i]
		// Обновляем значения вектора свободных членов для предыдущих уравнений
		for j := i - 1; j >= 0; j-- {
			B[j] -= A[j][i] * X[i]
		}
	}

	// Возвращаем массив решений
	return X, nil
}
