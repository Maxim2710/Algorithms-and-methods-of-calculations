package task3

import (
	"Algorithms/laboratory_work3/controller"
	"math"
)

// Якобиан системы уравнений
func jacobian(x, y float64) (float64, float64, float64, float64) {
	// Здесь определяется матрица Якоби
	df1_dx := -1.0            // Производная первого уравнения по x
	df1_dy := math.Cos(y + 1) // Производная первого уравнения по y
	df2_dx := -math.Sin(x)    // Производная второго уравнения по x
	df2_dy := 2.0             // Производная второго уравнения по y

	return df1_dx, df1_dy, df2_dx, df2_dy // Возвращаем значения производных
}

// Метод Ньютона-Рафсона для решения системы уравнений
func NewtonRaphson(x, y float64, tolerance float64) (float64, float64) {
	for {
		// Получаем значения функций системы уравнений
		f1, f2 := controller.Equations(x, y)

		// Получаем значения производных (Якобиана) для текущих значений x и y
		df1_dx, df1_dy, df2_dx, df2_dy := jacobian(x, y)

		// Находим определитель матрицы Якоби
		determinant := df1_dx*df2_dy - df1_dy*df2_dx

		// Находим обратную матрицу Якоби
		inv_df1_dx := df2_dy / determinant
		/*
			Здесь вычисляется элемент матрицы, который находится на пересечении первой строки и первого
			столбца обратной матрицы. Этот элемент равен производной второго уравнения по y, деленной на
			определитель матрицы Якоби.
		*/
		inv_df1_dy := -df1_dy / determinant
		/*
		   Этот элемент обратной матрицы находится на пересечении первой строки и второго столбца.
		   Он равен отрицательной производной первого уравнения по y, деленной на определитель
		   матрицы Якоби.
		*/
		inv_df2_dx := -df2_dx / determinant
		/*
			Элемент этой строки и первого столбца обратной матрицы равен отрицательной производной второго
			уравнения по x, деленной на определитель матрицы Якоби.
		*/
		inv_df2_dy := df1_dx / determinant
		/*
		   Аналогично, этот элемент, находящийся на пересечении второй строки и второго столбца,
		   равен производной первого уравнения по x, деленной на определитель матрицы Якоби.
		*/

		// Вычисляем приращения
		dx := inv_df1_dx*f1 + inv_df1_dy*f2
		dy := inv_df2_dx*f1 + inv_df2_dy*f2

		// Обновляем значения x и y
		x -= dx
		y -= dy

		// Проверяем условие сходимости
		if math.Abs(dx) < tolerance && math.Abs(dy) < tolerance {
			break
		}
	}
	return x, y // Возвращаем найденные значения x и y
}
